// Provider Code Generator
// 
// Safe code generation for new swap providers with validation
// and guardrails to prevent malicious or broken code.

import Anthropic from '@anthropic-ai/sdk';
import { testGeneratedCode } from './provider-testing';

/**
 * Generated provider output
 */
export interface GeneratedProvider {
  name: string;
  className: string;
  code: string;
  testCode: string;
  filename: string;
  validated: boolean;
  validationErrors: string[];
  integrationNotes: string;
}

/**
 * Provider API analysis result
 */
export interface ProviderApiAnalysis {
  name: string;
  baseUrl: string;
  hasPublicApi: boolean;
  endpoints: {
    currencies?: string;
    rate: string;
    create: string;
    status: string;
  };
  authMethod: 'none' | 'apiKey' | 'signature' | 'oauth';
  requestFormat: 'json' | 'form' | 'query';
  responseFormat: 'json' | 'xml';
  notes: string;
  confidence: number;
}

/**
 * Provider template - base code structure that Claude fills in
 */
const PROVIDER_TEMPLATE = `// Auto-generated provider implementation
// Generated by SafePay AI Provider Discovery System
// 
// IMPORTANT: This code was automatically generated and has passed
// static analysis, but requires manual review before integration.
// 
// Review checklist:
// [ ] API endpoints are correct
// [ ] Error handling is appropriate
// [ ] Rate limiting is respected
// [ ] No sensitive data exposure
// [ ] Response mapping is accurate

import type { SwapProvider } from '../shared';
import type { 
  ISwapProvider, 
  SupportedCoin, 
  SwapQuote, 
  SwapDetails, 
  SwapStatus,
  ProviderConfig 
} from './interfaces';

/**
 * {{PROVIDER_NAME}} Provider Implementation
 * 
 * API Documentation: {{API_DOC_URL}}
 * Generated: {{GENERATION_DATE}}
 */
export class {{CLASS_NAME}} implements ISwapProvider {
  readonly name: SwapProvider = '{{PROVIDER_ID}}' as SwapProvider;
  readonly displayName = '{{DISPLAY_NAME}}';
  readonly enabled = true;
  
  private readonly baseUrl = '{{BASE_URL}}';
  private readonly timeout: number;
  
  constructor(config?: ProviderConfig) {
    this.timeout = config?.timeout ?? 30000;
  }
  
  /**
   * Make HTTP request with timeout and error handling
   */
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    
    try {
      const response = await fetch(\`\${this.baseUrl}\${endpoint}\`, {
        ...options,
        signal: controller.signal,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          ...options.headers,
        },
      });
      
      if (!response.ok) {
        throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
      }
      
      return await response.json();
    } finally {
      clearTimeout(timeoutId);
    }
  }
  
  {{IMPLEMENTATION_CODE}}
}
`;

/**
 * Get the Anthropic client
 */
function getAnthropicClient(): Anthropic | null {
  if (!process.env.ANTHROPIC_API_KEY) {
    return null;
  }
  return new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
}

/**
 * Analyze a provider's API documentation to understand its structure
 */
export async function analyzeProviderApi(
  providerName: string,
  apiDocUrl: string
): Promise<ProviderApiAnalysis | null> {
  const client = getAnthropicClient();
  if (!client) {
    console.log('[CodeGenerator] No Claude API key available');
    return null;
  }
  
  console.log(`[CodeGenerator] Analyzing ${providerName} API at ${apiDocUrl}`);
  
  try {
    const response = await client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 4096,
      messages: [{
        role: 'user',
        content: `Analyze the cryptocurrency swap API for ${providerName}.
API Documentation URL: ${apiDocUrl}

Based on your knowledge of this API, provide a detailed analysis in JSON format:

{
  "name": "${providerName}",
  "baseUrl": "base API URL",
  "hasPublicApi": true/false (can it be used without API key?),
  "endpoints": {
    "currencies": "endpoint to get supported currencies (optional)",
    "rate": "endpoint to get exchange rate",
    "create": "endpoint to create a swap",
    "status": "endpoint to check swap status"
  },
  "authMethod": "none" | "apiKey" | "signature" | "oauth",
  "requestFormat": "json" | "form" | "query",
  "responseFormat": "json" | "xml",
  "notes": "any important implementation notes",
  "confidence": 0.0-1.0 confidence score
}

Only return the JSON object, nothing else.`
      }],
    });
    
    const content = response.content[0];
    if (content.type === 'text') {
      const jsonMatch = content.text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
    }
  } catch (error: any) {
    console.error(`[CodeGenerator] API analysis failed:`, error.message);
  }
  
  return null;
}

/**
 * Generate provider implementation code using Claude
 */
export async function generateProviderCode(
  analysis: ProviderApiAnalysis
): Promise<GeneratedProvider | null> {
  const client = getAnthropicClient();
  if (!client) {
    console.log('[CodeGenerator] No Claude API key available');
    return null;
  }
  
  if (!analysis.hasPublicApi) {
    console.log(`[CodeGenerator] ${analysis.name} requires authentication, skipping`);
    return null;
  }
  
  console.log(`[CodeGenerator] Generating code for ${analysis.name}`);
  
  const className = `${analysis.name.replace(/[^a-zA-Z0-9]/g, '')}Provider`;
  const providerId = analysis.name.toLowerCase().replace(/[^a-z0-9]/g, '');
  
  try {
    const response = await client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 8192,
      messages: [{
        role: 'user',
        content: `Generate the implementation methods for a TypeScript swap provider class.

Provider Details:
${JSON.stringify(analysis, null, 2)}

Generate ONLY the method implementations that go inside the class (not the full class).
The class already has:
- this.baseUrl set to "${analysis.baseUrl}"
- this.request<T>(endpoint, options) helper method for HTTP calls
- this.timeout for request timeout

Generate these methods:
1. getSupportedCoins(): Promise<SupportedCoin[]>
2. isPairSupported(fromCurrency, fromNetwork, toCurrency, toNetwork): Promise<boolean>
3. getQuote(fromCurrency, fromNetwork, toCurrency, toNetwork, withdrawAmount): Promise<SwapQuote | null>
4. createSwap(fromCurrency, fromNetwork, toCurrency, toNetwork, withdrawAmount, withdrawAddress, withdrawMemo?): Promise<SwapDetails>
5. getSwapStatus(swapId): Promise<SwapStatus>

Requirements:
- Map API responses to our standard interfaces
- Handle errors gracefully (return null for quotes when pair not supported)
- Include JSDoc comments
- Use proper TypeScript types
- Map provider's status values to: 'waiting' | 'confirming' | 'exchanging' | 'sending' | 'finished' | 'failed' | 'refunded' | 'expired'

Return a JSON object:
{
  "implementationCode": "// The TypeScript method implementations",
  "testEndpoints": ["list of endpoints used"],
  "integrationNotes": "any important notes for reviewers"
}`
      }],
    });
    
    const content = response.content[0];
    if (content.type !== 'text') {
      throw new Error('Unexpected response type');
    }
    
    // Parse response
    let implementationCode: string;
    let integrationNotes: string;
    
    const jsonMatch = content.text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      implementationCode = parsed.implementationCode;
      integrationNotes = parsed.integrationNotes || '';
    } else {
      // Try to extract code directly
      implementationCode = content.text;
      integrationNotes = 'Code extracted directly from response';
    }
    
    // Build full code from template
    const fullCode = PROVIDER_TEMPLATE
      .replace(/\{\{PROVIDER_NAME\}\}/g, analysis.name)
      .replace(/\{\{CLASS_NAME\}\}/g, className)
      .replace(/\{\{PROVIDER_ID\}\}/g, providerId)
      .replace(/\{\{DISPLAY_NAME\}\}/g, analysis.name)
      .replace(/\{\{BASE_URL\}\}/g, analysis.baseUrl)
      .replace(/\{\{API_DOC_URL\}\}/g, analysis.baseUrl)
      .replace(/\{\{GENERATION_DATE\}\}/g, new Date().toISOString())
      .replace(/\{\{IMPLEMENTATION_CODE\}\}/g, implementationCode);
    
    // Validate generated code
    const validation = await testGeneratedCode(fullCode, className);
    
    // Generate test code
    const testCode = generateTestCode(className, providerId);
    
    return {
      name: analysis.name,
      className,
      code: fullCode,
      testCode,
      filename: `${providerId}.ts`,
      validated: validation.success,
      validationErrors: validation.success ? [] : [validation.error || 'Unknown validation error'],
      integrationNotes,
    };
  } catch (error: any) {
    console.error(`[CodeGenerator] Code generation failed:`, error.message);
    return null;
  }
}

/**
 * Generate test code for the provider
 */
function generateTestCode(className: string, providerId: string): string {
  return `// Auto-generated tests for ${className}
import { ${className} } from './${providerId}';
import { testProvider } from '../../lib/provider-testing';

describe('${className}', () => {
  const provider = new ${className}();
  
  it('should pass provider test suite', async () => {
    const results = await testProvider(provider);
    expect(results.safeToIntegrate).toBe(true);
  }, 60000);
  
  it('should get supported coins', async () => {
    const coins = await provider.getSupportedCoins();
    expect(Array.isArray(coins)).toBe(true);
  });
  
  it('should check pair support', async () => {
    const supported = await provider.isPairSupported('BTC', 'BTC', 'USDT', 'TRX');
    expect(typeof supported).toBe('boolean');
  });
  
  it('should get quote', async () => {
    const quote = await provider.getQuote('BTC', 'BTC', 'USDT', 'TRX', 100);
    // Quote can be null if pair not supported
    if (quote !== null) {
      expect(quote).toHaveProperty('provider');
      expect(quote).toHaveProperty('depositAmount');
      expect(quote).toHaveProperty('receiveAmount');
    }
  });
  
  it('should handle invalid swap status gracefully', async () => {
    // Should not throw
    await expect(provider.getSwapStatus('invalid-id')).resolves.toBeDefined();
  });
});
`;
}

/**
 * Validate that generated code is safe and follows our standards
 */
export function validateGeneratedCode(code: string): {
  valid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  // Check for dangerous patterns
  const dangerousPatterns = [
    { pattern: /eval\s*\(/, message: 'eval() is not allowed' },
    { pattern: /Function\s*\(/, message: 'Function constructor is not allowed' },
    { pattern: /process\.exit/, message: 'process.exit() is not allowed' },
    { pattern: /require\s*\([^'"]*\)/, message: 'Dynamic require is not allowed' },
    { pattern: /fs\.\w+/, message: 'Filesystem access is not allowed' },
    { pattern: /child_process/, message: 'Child process is not allowed' },
    { pattern: /\.exec\s*\(/, message: 'exec() is not allowed' },
    { pattern: /while\s*\(\s*true\s*\)/, message: 'Infinite loops are not allowed' },
  ];
  
  for (const { pattern, message } of dangerousPatterns) {
    if (pattern.test(code)) {
      errors.push(message);
    }
  }
  
  // Check for required interface implementation
  const requiredMethods = [
    'getSupportedCoins',
    'isPairSupported',
    'getQuote',
    'createSwap',
    'getSwapStatus',
  ];
  
  for (const method of requiredMethods) {
    if (!code.includes(`async ${method}`) && !code.includes(`${method}(`)) {
      errors.push(`Missing required method: ${method}`);
    }
  }
  
  // Check for proper error handling
  if (!code.includes('try') || !code.includes('catch')) {
    warnings.push('Consider adding try/catch error handling');
  }
  
  // Check for timeout handling
  if (!code.includes('timeout') && !code.includes('Timeout')) {
    warnings.push('Consider adding request timeout handling');
  }
  
  // Check code length (too short = likely incomplete)
  if (code.length < 1000) {
    errors.push('Generated code seems too short - likely incomplete');
  }
  
  // Check code length (too long = potential bloat)
  if (code.length > 50000) {
    warnings.push('Generated code is very long - consider optimization');
  }
  
  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}
